;; ===============================================================================================================
;; Macro to define classes
;;
;; A. Buchet - July 2025
;; ===============================================================================================================


(let ( _obj )

  (@fun _\@set_built_obj
    ( ( obj ?type stdobj )
      )
    ?doc    "Cache OBJ so it can be retrieved at the proper time using `@built_obj'"
    ?out    stdobj
    ?global t
    (setq _obj obj)
    )

  (@fun @built_obj ()
    ?doc "Return the object currently being built.
This is meant to be used inside `defclass' slot @initform arguments to make dependent arguments.

For this to work, an `initializeInstance @before' method should be defined and use `_\\@set_built_obj'
to define the object being built.

This is managed by default when using `@class'."
    ?out    stdobj
    ?global t
    _obj
    )

  );closure

(@fun _\@class_builder
  ( ( builder_name ?type symbol )
    ( class_name   ?type symbol )
    ( doc          ?type string )
    ( slots        ?type list   )
    )
  ?doc "`@class' helper to generate builder function."
  ?out list
  (list
    ;; Define builder arglist, only for documentation purposes
    `(setf (@arglist ',builder_name)
       ',(cons '@key
          (foreach mapcan slot slots
             (let ( ( slot_name (cadr (member '@initarg slot )))
                    )
               (when slot_name
                 (let ( ( value (member '@initform slot) )
                        )
                   (list (list (concat ? slot_name) (if value (car value) '\*slotUnbound\*)))
                   ));let ;when
               ));let ;foreach
         ));cons ;setf
    ;; Actual builder definition
    `(defglobalfun ,builder_name (@rest args)
       ,(lsprintf "%s class builder (generated by `@class').\n\n%s" class_name doc)
       (apply 'makeInstance ',class_name args)
       );def
     ));list ;def

(@fun _\@class_slots
  ( ( class_name ?type symbol       )
    ( slots      ?type ( list ... ) )
    )
  ?doc "Parse enhanced class slots in order to generate a list understandable by `defclass'"
  ?out list
  (foreach mapcar slot slots
    ;; TODO - Clean class slot and expand shortcuts
    (destructuringBind ( name @key ( init '__unbound__ ) doc type @rest args ) slot
      ;; TODO - Properly store slots doc and type in documentation
      ;; TODO - Use slots types for type-checking in builder
      ;; Lint waivers for now
      doc type
      ;; Return actual `defclass' slots definition
      `( ,name
         ,@(unless (eq '__unbound__ init) (list '@initform init))
         ,@(foreach mapcan arg args
             (@caseq arg
               ( @arg `( @initarg  ,name )                                                                )
               ( @nil '( @initform nil   )                                                                )
               ( @err `( @initform (error "%s" ,(@str "Class {class_name} - slot {name} is required!")) ) )
               ))
          ))
    ))

;; TODO - Check that class builder arglist is well defined
(@macro @class ( @key name doc super (builder t) @rest slots )
  "TODO - `@class' is still at draft state..."
  ;; Evaluate arguments
  ;; TODO - `eval' in macro is not recommended and do not support SKILL++ environment
  (setq name    (eval name    (theEnvironment)))
  (setq super   (eval super   (theEnvironment)))
  (setq builder (eval builder (theEnvironment)))
  (setq slots   (_\@class_slots name slots)    )
  (let ( ( builder_name (if (and (symbolp builder) (neq t builder)) builder name) )
         )
    ;; Build `defclass' call
    `(progn
       (defclass ,name ,super ,slots)
       (defmethod initializeInstance @before ( ( obj ,name ) @rest _ )
         "Set OBJ as currently built one, so it can be accessed in class default values."
         (_\@set_built_obj obj)
         )
       ;; Define builder when provided
       ,@(when builder (_\@class_builder builder_name name doc slots))
        );progn
     ));let ;macro

;*/

